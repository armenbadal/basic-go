# Լեզվի նկարագրությունը

_Բալը_ տպերի դինամիկ ստուգումով (dynamically typed) և խիստ տիպիզացված (strong typed) լեզու է։ Հիմնականում ընդօրինակված լինելով Բեյսիկ լեզվից, այն որոշ հատկություններ է յուրացրել նաև Պիթոնից ու ՋավաՍկրիպտից։ Փոփոխակաները տիպավորված չեն․ ծրագրի կատարման ընթաքում նույն անունով փոփոխականին կարող են համապատասխանեցվել տարբեր տիպի արժեքներ։ Արժեքների տիպերը ստուգվում են օգտագործման կետում։ Օրինակ, հետևյալ ծրագրում `a` փոփոխականին վերագրվում է նախ՝ իրական արժեք, ապա՝ տեքստային.

```basic
SUB Main
    LET a = 3.14159
    PRINT a
    LET a = "A line of text."
    PRINT a
END SUB
```

Բալի քերականությունը սահմանելու համար օգտագործել եմ _Բեկուսի֊Նաուրի ընդլայնված գրառումը_ (EBNF, տես՝ Wirth, _Compiler construction_)։ Այս քերականությունը, ինչպես նաև դրա վերլուծության իրականացումը, զերծ չեն թերություններից ու անհստակություններից։

__Ծրագիր։__ Բալ ծրագիրը՝ `Program`, ենթածրագրերի հաջորդականություն է։ Դա արտահայտվում է հետևյալ _քերականական հավասարմամբ_.

```
Program = { Subroutine }.
```

Այստեղ `{` և `}` փակագծերը նշանակում են «պարփակված արտահայտության զրո կամ ավելի կրկնություններ»։ Տվյալ դեպքում՝ գրված է, որ `Program`-ը `Subroutine` տարրի զրո և ավելի անգամ կրկնություններ է։

_Ենթածրագիրը_՝ `Subroutine`, ինքնուրույն, իմաստալից գործողության սահմանումն է։ Այն կարող է ստանալ արգումենտներ՝ իր պարամետրերի միջոցով, և վերադարձնել արժեք։

```
Subroutine = 'SUB' IDENT ['(' IdentList ')'] Sequence 'END' SUB'.
IdentList = [IDENT {',' IDENT}].
```

Այստեղ օգտագործված `[` և `]` փակագծերով որոշվում է «պարփակված արտահայտության առկայություն կամ բացակայություն»։ Այսինքն՝ տվյալ դեպքում նշված է, որ իդենտիֆիկատորների ցուցակը կարող է նաև դատարկ լինել։ Նաև նշված է, որ եթե պարամետրերի ցուցակը դատարկ է, ապա կարելի է բաց թողնել նաև կլոր փակագծերը։ Օրինակ, ենթածրագրերի հետևյալ վերնագրերը համարժեք են.

```Basic
SUB Ok()
    PRINT "Ok"
END SUB
```

Կամ.

```Basic
SUB Ok
    PRINT "Ok"
END SUB
```

Ենթածրագրերի մարմնում գործողությունները նկարագրվում են որպես _հրամանների հաջորդականություն_՝ `Sequence`։ Հաջորդականությունը սկսվում է մեկ կամ ավելի _նոր տողերի_ նիշերվ, իսկ ամեն մի հրամանին նորից պետք է հաջորդեն մեկ կամ ավելի նոր տողեր։

```
Sequence = NewLines { Statement NewLines }.
NewLines = NEWLINE { NEWLINE }.
```

Լեզվի հրամանները (կամ ղեկավարող կառուցվածքները) ութն են՝ նախատեսված միաչափ զանգվածների սահմանման, վերագրման, ներմուծման ու արտածման, ճյուղավորման, կրկնությունների և ենթածրագրի կանչի համար։ 

__Զանգված։__ Միաչափ զանգվածները (կամ վեկտորները) սահմանվում են `DIM` հրամանով։ Այն ստանում է զանգվածի անունն ու տարրերի քանակը, որը կարող է լինել ոչ միայն հաստատուն, այլև կատարման ժամանակ հաշվարկվող արտահայտություն՝ թվային արժեքով։

```
Statement = 'DIM' IDENT '[' Expression ']'.
```

Օրինակ, հայտարարենք յոթ տարրերի `arr` զանգվածը։

```Basic
DIM arr[7]
```

Զանգվածի երկարությունը կարելի է ստանալ `LEN()` ֆունկցիայով։ Օրինակ.

```Basic
PRINT LEN(arr) ' կարտածվի 7
```

__Վերագրում։__ Փոփոխականին, կամ զանգվածի տարրին նոր արժեք վերագրելու համար նախատեսված է `LET` հրամանը․

```
Statement = 'LET' IDENT {'[' Expression ']'} '=' Expression.
```

Օրինակ․

```Basic
LET pi = 3.1415         ' pi փոփոխականին վերագրել 3.1415 արժեքը
LET days[0] = "Monday"  ' days զանգվածի առաջին տարրին վերագրել Monday արժեքը
```

__Ներմուծում և արտածում։__ Ներմուծման ստանդարտ հոսքից տվյալների ներմուծման համար է նախատեսված `INPUT` հրամանը։ Այն թույլ է տալիս ներմուծել տրամաբանական, թվային ու տեքստային արժեքներ։

```
Statement = 'INPUT' IDENT.
```

Տվյալների արտածման համար նախատեսված է `PRINT` հրամանը։ Այն կարողանում է արտածել տրամաբանական, թվային ու տեքստային արժեքները, ինչպես նաև զանգվածները։

```
Statement = 'PRINT' Expression.
```

Օրինակ, հետևյալ ծրագիրը պահանջում է ներմուծել երկու թվեր, ապա արտածում է դրանց արտադրյալը։ Բնականաբար, ներմուծված արժեքների թվային լինելը ստուգվում է արտադրյալի հաշվարկման ժամանակ։

```Basic
SUB Main
    INPUT x
    INPUT y
    PRINT x * y
END SUB
```

> Առայժմ `INPUT` հրամանը «չի կարողանում» ներմուծել զանգվածի տարրերը։ 

__Ճյուղավորում։__ `IF` կառուցվածով, ինչպես և սպասվում էր, կազմակերպվում են ճյուղավորումները։ Հետևյալը սահմանում է, որ `IF` կառուցվածքը կարող է ունենալ մի քանի `ELSEIF`-եր, իսկ `ELSE` ճյուղի առկայությունը պարտադիր չէ։

```
Statement = 'IF' Expression 'THEN' Sequence
            { 'ELSEIF' Expression 'THEN' Sequence }
            [ 'ELSE' Sequence ]
            'END' 'IF'.
```

Օրինակ, հետևյալ ենթածրագիրը հաշվում և վերադարձնում է արգումենտում տրված երկու թվերից ավլի մեծը։

```Basic
SUB Max(x, y)
    IF x > y THEN
        LET Max = x
    ELSE
        LET Max = y
    END IF
END SUB
```


__Կրկնություն։__ Բա լեզվում կրկնություններ կազմակերպելու հրամանները երկուսն են. `WHILE` -- նախապայմանով կրկնությունների համար, և `FOR` -- հաշվիչով կրկնությունների համար։

`WHILE` հրամանի քերականությունը հետևյալն է։ `Sequence` բլոկը կատարվում է այնքան ժամանակ, քանի դեռ _ճշմարիտ_ է `Expression` արտահայտությունը։ 

```
Statement = 'WHILE' Expression Sequence 'END' 'WHILE'.
```

Օրինակ, սահմանեմ մի ենթածրագիր, որը հաշվում ու վերադարձնում է տրված թվի թվանշանների քանակը։

```Basic
SUB CountDigits(n)
    LET count = 0
    WHILE n <> 0
        LET n = n \ 10
        LET count = count + 1
    END WHILE
    LET CountDigits = count
END SUB
```

`FOR` հրամանը սահմանում է նոր փոփոխական՝ _պարամետր_, տալիս է դրան սկզբնական արժեք և կատարում է ցիկլի մարմնի `Sequence` բլոկն այնքան ժամանակ, քանի դեռ պարամետրի արժեքը չի հավասարվել վերջնական արժեքին։ Եթե `STEP`-ը տրված չէ, ապա պարամետրի արժեքը փոխվում է 1-ով։

```
Statement = 'FOR' IDENT '=' Expression 'TO' Expression ['STEP' ['+'|'-'] NUMBER]
            Sequence 'END' 'FOR'.
```

Օրինակ, հետևյալ ծրագիրը հաշվում ու տպում է 20-ից մինչև 100 միջակայքի զույգ թվերի գումարը։

```Basic
SUB Main
    LET sum = 0
    FOR i = 20 TO 100 STEP 2
        LET sum = sum + i
    END FOR
    PRINT sum
END SUB
```

__Ենթածրագրի կանչ։__ `CALL` հրամանը կանչում է տրված անունով ենթածրագիրը որպես հրաման, դրան փոխանցելով նշված արգումենտները; Բնականաբար, արգումենտների ցուցակը կարող է դատարկ լինել։ 

```
Statement = 'CALL' IDENT [Expression {',' Expression}].
```

Օրինակ, հետևյալ ծրագիրը կանչում է `PrintN` ենթածրագիրը՝ տրված արժեքը տրված քանակով տպելու համար։

```Basic
SUB PrintN(value, number)
    WHILE number > 0
        PRINT value
        LET number = number - 1
    END WHILE
END SUB

SUB Main
    CALL PrintN "Ok", 4
    CALL PrintN "Yes", 2
END SUB
```

Հրամանները սահմանված են իրենց քերականական հավասարումներով։ Այս պահին միակ չսահմանված քերականական տարրը `Expression`-ն է՝ _արտահայտությունը_։ Գործողությունների զուգորդականությունն (assocaitivity) ու նախապատվությունը (priority) ճիշտ ապահովելու համար արտահայտությունների քերականական հավասարումենրը գրված են «մակարդակներով»։ Հետևյալ աղյուսակի տողերում գործողությունները դասավորված են ըստ նախապատվությունների աճման.

| Գործողություն          | Իմաստ |
| :-------------------: | :--- | 
| `OR`                  | տրամաբանական ԿԱՄ |
| `AND`                 | տրամաբանական ԵՎ |
| `=`, `<>`             | հավասարություն, անհավասարություն |
| `<`,  `<=`, `>`, `>=` | համեմատումներ |
| `+`, `-`, `&`         | գումարում, հանում, տեքստերի կցում |
| `*`, `/`, `\`         | բազմապատկում, բաժանում, քանորդ |
| `^`                   | աստիճան բարձրացնել |
| `[]`                  | զանգվածի տարր |
| `()`                  | խմբավորում |
| `-`, `+`, `NOT`       | ունար մինուս, պլյուս, ժխտում |


Արտահայտությունները սահմանեմ ամենատարրական, անտրոհելի տարրերից սկսած։ Այդ ամենապարզ տարրերի խմբին քերականական հավասարումներում հաճախ անվանում են _Factor_։ Դրանք են փոփոխականները, տրամաբանական, թվային, տեքստային լիտերալները, ինչպես նաև զանգվածի լիտերալը.

```
Factor = 'TRUE' | 'FALSE' | NUMBER | TEXT | IDENT | ArrayLiteral.
ArrayLiteral = '[' [ Expression { ',' Expression } ] ']'.
```

Հետևյալները տարրական արտահայտությունների օրինակներ են.

```Basic
TRUE            ' «ճշմարիտ» արժեք
FALSE           ' «կեղծ» արժեք
3.1415          ' թիվ
777             ' թիվ 
"Սա տեքստ է։"  ' տեքստ
[1, 2, 3, 4]    ' զանգված
```

Պարզագույն արտահայտություններ են ունար գործողությունների կիրառումը, ենթածրագիր-ֆունկցիայի կիրառումը և խմբավորման փակագծերը.

```
Simplest = Factor 
         | ('-' | 'NOT') Simplest
         | IDENT '(' [ Expression { ',' Expression } ] ')' 
         | '(' Expression ')'.
```

Օրինակներ.

```Basic
-88                ' բացասում
NOT (a = "Ok")     ' ժխտում
MID("Text", 2, 1)  ' ֆունկցիայի կանչ
(3 + 4) * 5        ' խմբավորման փակագծեր
```

Զանգվածի տարրին ինդեքսով դիմելու գործողությունը սահմանել եմ որպես բինար գործողություն.

```
Subscript = Simplest [ '[' Expression ']' ].
```

Աստիճան բարձրացնելու գործողությունը, որ ունի բարձր նախապատվություն և, ի տարբերություն մյուս երկտեղանի գործողությունների, աջ-զուգորդվող է.

```
Power = Subscript [ '^' Power ].
```

Մեր համատեքստում «աջ-զուգորդվող» նշանակում է, որ աստիճան բարձրացնելու գործողությամբ շղթաներ կազմելիս, օրինակ, `a^b^c^d`, գործողությունները կատարվում են աջից ձախ՝ `a^(b^(c^d))` օրենքով, այլ ոչ թե ձախից աջ, ինչպես դա արվում է գումարման կամ բազմապատկման գործողությունների համար (օրինակ, `a+b+c+d = ((a+b)+c)+d`)։

Մուլտիպլիկատիվ գործողությունների նախապատվությունը մի ատիճանով բարձր է ադիտիվ գործողությունների նախապատվությունից։ Քանի որ տեքստերի միակցման `&` գործողությունն իր իմաստով ադիտիվ է, ես այն սահմանել եմ թվերի գումարման ու հանման գործողությունների շարքում։ Ահա դրանց հավասարումները.

```
Addition = Multiplication { ('+' | '-' | '&') Multiplication }.
Multiplication = Power { ('*' | '/' | '\') Power }.
```

Այսպիսի սահմանումը հնարավորություն է տալիս բանաձևերը գրելիս օգտագործել մաթեմատիկայից հայտնի զուգորդական օրենքները։ Օրինակ, եթե գրում ենք `LET D = b^2-4*a*c`, ապա հասկանում ենք (և Բալն էլ հասկանում է), որ գրած է `LET D = (b^2)-((4*a)*c)`։

Համեմատման գործողություններն էլ բաժանված են երկու մակարդակի. առաջինում հավասարության ու անհավասարության ստուգման գործողություններն են, երկրորդում՝ համեմատման մյուս գործողությունները։ Սա, իհարկե, խիստ անհրաժեշտություն չէ, և շատ տեղերում էլ համեմատման բոլոր վեց գործողությունները սահմանվում են մեկ հավսարմամբ։ Այնուամենայնիվ, այսպիսի տրոհումը թույլ է տալիս գրել `5 > 4 = a >= b` տեսքի արտահայտություն և այն հասկանալ որպես `(5 > 4) = (a >= b)`։ Եթե բոլոր վեց գործողություններն էլ սահմանված լինեին նույն քերականական հավասարմամբ, ապա պարզապես ստիպված կլինեինք բացահայտ փակագծեր դնել։

```
Equality = Comparison [ ('=' | '<>') Comparison ].
Comparison = Addition [ ('<' | '<=' | '>' | '>=') Addition ].
```

Եւ վերջապես, Բալ լեզվի արտհայտությունների ամենացածր նախապատվությունն ունեցող գործողությունները՝ տրամաբանական կոնյունկցիան ու դիզյունքցիան։ 

```
Expression = Conjunction { 'OR' Conjunction }.
Conjunction = Equality { 'AND' Equality }.
```
