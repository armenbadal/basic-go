# Լեզվի նկարագրությունը

_Բալը_ տպերի դինամիկ ստուգումով (dynamically typed) և խիստ տիպիզացված (strong typed) լեզու է։ Հիմնականում ընդօրինակված լինելով Բեյսիկ լեզվից, այն որոշ հատկություններ է յուրացրել նաև Պիթոնից ու ՋավաՍկրիպտից։ Փոփոխակաները տիպավորված չեն․ ծրագրի կատարման ընթաքում նույն անունով փոփոխականին կարող են համապատասխանեցվել տարբեր տիպի արժեքներ։ Արժեքների տիպերը ստուգվում են օգտագործման կետում։ Օրինակ, հետևյալ ծրագրում `a` փոփոխականին վերագրվում է նախ՝ իրական արժեք, ապա՝ տեքստային.

```basic
SUB Main
    LET a = 3.14159
    PRINT a
    LET a = "A line of text."
    PRINT a
END SUB
```

Բալի քերականությունը սահմանելու համար օգտագործել եմ _Բեկուսի-Նաուրի ընդլայնված գրառումը_ (EBNF, տես՝ Wirth, _Compiler construction_)։ (NB Գրքի տեքստում բերված քերականությունը որոշ նրբություններով կարող է տարբերվել Բալի ինտերպրետատորի իրականացման մեջ օգտագործվածից։)

__Ծրագիր։__ Բալ ծրագիրը՝ `Program`, ենթածրագրերի հաջորդականություն է։ Դա արտահայտվում է հետևյալ _քերականական հավասարմամբ_.

```
Program = { Subroutine }.
```

Այստեղ `{` և `}` փակագծերը նշանակում են «պարփակված արտահայտության զրո կամ ավելի կրկնություններ»։ Տվյալ դեպքում՝ գրված է, որ `Program`-ը սահմանվում է որպես `Subroutine` տարրի զրո և ավելի անգամ կրկնություններ։


__Ենթածրագիրը__՝ `Subroutine`, ինքնուրույն, իմաստալից գործողության սահմանումն է, համարժեքն է համարյա բոլոր ծրագրավորման լեզուներում հանդիպող պրոցեդուրաներին կամ ֆունկցիաներին։ Այն կարող է ստանալ արգումենտներ՝ իր պարամետրերի միջոցով, և վերադարձնել արժեք։

```
Subroutine = 'SUB' IDENT ['(' [IdentList] ')'] Sequence 'END' SUB'.
IdentList = IDENT {',' IDENT}.
```

Այստեղ օգտագործված `[` և `]` փակագծերով որոշվում է «պարփակված արտահայտության առկայություն կամ բացակայություն»։ Այսինքն՝ տվյալ դեպքում նշված է, որ իդենտիֆիկատորների ցուցակը կարող է նաև դատարկ լինել։ Գրվածից նաև հետևում է, որ երբ պարամետրերի ցուցակը դատարկ է, ապա կարելի է բաց թողնել նաև կլոր փակագծերը։ Օրինակ, ենթածրագրերի `SUB Ok()` և `SUB Ok` վերնագրերը համարժեք են։

Հիմա տեղին է նշել, որ Բալը ենթածրագրից արժեք վերադարձնող հատուկ հրաման չունի (ինչպիսին է, օրինակ Go-ի `return`-ը): Վերադարձվող արժեքը վերագրվում է ենթածրագրի անունին։ Օրինակ, հետևյալ ենթածրագիրը, հաշվում ու վերադարձնում է երկու արժեքներից մեծը․

```basic
SUB Maximum(x, y)
    LET Maximum = x
    IF y > Maximum THEN
        LET Maximum = y
    END IF
END SUB
```

Ենթածրագրերի մարմնում գործողությունները նկարագրվում են որպես _հրամանների հաջորդականություն_՝ `Sequence`։ Վերը բերված `Maximum` ենթածրագիր մարմնում հրամանների հաջորդականությունն ունի երկու տարր․ `LET` և `IF`: Հաջորդականությանը պետք է նախորդեն մեկ կամ ավելի _նոր տողերի_ նիշեր, իսկ ամեն մի հրամանին նորից պետք է հաջորդեն մեկ կամ ավելի նոր տողերի նիշեր։

```
Sequence = NewLines { Statement NewLines }.
NewLines = NEWLINE { NEWLINE }.
```

Լեզվի հրամանները (կամ ղեկավարող կառուցվածքները) ութն են՝ նախատեսված միաչափ զանգվածների սահմանման, վերագրման, ներմուծման ու արտածման, ճյուղավորման, կրկնությունների և ենթածրագրի կանչի համար։ 


__Զանգվածի սահմանում։__ Միաչափ զանգվածները (կամ վեկտորները) սահմանվում են `DIM` հրամանով։ Այն ստանում է զանգվածի անունն ու տարրերի քանակը, որը կարող է լինել ոչ միայն հաստատուն, այլև կատարման ժամանակ հաշվարկվող արտահայտություն՝ թվային արժեքով։

```
Statement = 'DIM' IDENT '[' Expression ']'.
```

Օրինակ, հայտարարենք յոթ տարրերի `arr` զանգվածը։

```basic
DIM arr[7]
```

Կատարման ժամանակ զանգվածի երկարությունը կարելի է ստանալ `LEN()` ներդրված ֆունկցիայով։ Օրինակ.

```basic
PRINT LEN(arr) ' կարտածվի 7
```

Այս օրինակում `'` նիշով սկսվում է Բալ լեզվի մեկնաբանությունը, որը շարունակվում է մինչև տողի վերջը։


__Վերագրում։__ Փոփոխականին, կամ զանգվածի տարրին նոր արժեք է վերագրվում `LET` հրամանով․

```
Statement = 'LET' IDENT {'[' Expression ']'} '=' Expression.
```

Օրինակ․

```Basic
LET pi = 3.1415         ' pi փոփոխականին վերագրել 3.1415 արժեքը
LET days[0] = "Monday"  ' days զանգվածի առաջին տարրին վերագրել Monday արժեքը
```

`LET` հրամանով կարելի է ստեղծել նաև զանգվածներ՝ վերագրման աջ կողմում տալով զանգվածի _լիտերալը_։ Այսպես․

```basic
LET vowels = ["ա", "է", "ը", "ի", "օ", "ու"]
```

Այս վերագրումը համարժեք է հետևյալ կոդին․

```basic
DIM vowels[6]
LET vowels[0] = "ա"
LET vowels[1] = "է"
LET vowels[2] = "ը"
LET vowels[3] = "ի"
LET vowels[4] = "օ"
LET vowels[5] = "ու"
```

Զանգվածի լիտերալի անդամները սահմանափակված չեն հաստատուններով, դրանք կարող ենք լինել արտահայտություններ, որոնք հաշվարկվելու են կատարման ժամանակ։


__Ներմուծում և արտածում։__ Ներմուծման ստանդարտ հոսքից տվյալների ներմուծման համար է նախատեսված `INPUT` հրամանը։ Այն թույլ է տալիս ներմուծել տրամաբանական, թվային ու տեքստային արժեքներ։

```
Statement = 'INPUT' IDENT.
```

> Առայժմ `INPUT` հրամանը «չի կարողանում» ներմուծել զանգվածի տարրերը։ 


Արտածման ստանդարտ հոսքին տվյալների դուրս բերման համար նախատեսված է `PRINT` հրամանը։ Այն կարողանում է արտածել տրամաբանական, թվային ու տեքստային արժեքները, ինչպես նաև զանգվածները։

```
Statement = 'PRINT' Expression.
```

Օրինակ, հետևյալ ծրագիրը պահանջում է ներմուծել երկու թվեր, ապա արտածում է դրանց արտադրյալը։ Բնականաբար, ներմուծված արժեքների թվային լինելը ստուգվում է արտադրյալի հաշվարկման ժամանակ։

```Basic
SUB Main
    INPUT x
    INPUT y
    PRINT x * y
END SUB
```

Զանգվածներն արտածելիս դրա տարրերը վերցվում են `[` և `]` փակագծերի մեջ ու իրարից անջատվում են ստորակետով։ Օրինակ, `PRINT vowels` հրամանը կատարելիս կտեսնենք․

```basic
["ա", "է", "ը", "ի", "օ", "ու"]
```


__Ճյուղավորում։__ `IF` կառուցվածով, ինչպես և սպասվում էր, կազմակերպվում են ճյուղավորումները։ Դրա համար գրված քերականական կանոնը սահմանում է, որ `IF` կառուցվածքը կարող է ունենալ մի քանի `ELSEIF`-եր (կամ չունենալ ընդհանրապես), իսկ `ELSE` ճյուղի առկայությունը պարտադիր չէ։

```
Statement = 'IF' Expression 'THEN' Sequence
            { 'ELSEIF' Expression 'THEN' Sequence }
            [ 'ELSE' Sequence ]
            'END' 'IF'.
```

`IF`-ի մի կիրառություն արդեն տեսանք ենթածրագրի սահմանմամ մեջ։ Այստեղ բերենք մի ուրիշ օրինակ, որը արեգակնային համակարգի ամեն մի մոլորակի համար արտածում է դրա հին հայկական անունը։

```basic
SUB OldArmenianNameOf(planet)
    IF planet = "Մերկուրի" THEN
        LET OldArmenianNameOf = "Փայլածու"
    ELSEIF planet = "Վեներա" THEN
       LET OldArmenianNameOf = "Արուսյակ"
    ELSEIF planet = "Մարս" THEN
       LET OldArmenianNameOf = "Հրատ"
    ELSEIF planet = "Յուպիտեր" THEN
       LET OldArmenianNameOf = "Լուսնթագ"
    ELSEIF planet = "Սատուրն" THEN
       LET OldArmenianNameOf = "Երևակ"
    ELSE
        LET OldArmenianNameOf = planet
    END IF
END SUB
```


__Կրկնություն։__ Բալ լեզվում կրկնություններ կազմակերպելու կառուցվածքները երկուսն են. `WHILE` -- նախապայմանով կրկնությունների համար, և `FOR` -- հաշվիչով կրկնությունների համար։

`WHILE` հրամանի քերականությունը այսպիսինն է․ 

```
Statement = 'WHILE' Expression Sequence 'END' 'WHILE'.
```

`Sequence` բլոկը կատարվելու է այնքան ժամանակ, քանի դեռ _ճշմարիտ_ է `Expression` արտահայտությունը։ Օրինակ, սահմանենք մի ենթածրագիր, որը հաշվում ու վերադարձնում է տրված դրական ամբողջ թվի թվանշանների քանակը՝ օգտագործելով բաժանման մնացորդը որոշող `\` գործողությունը։

```Basic
SUB CountDigits(n)
    LET count = 0
    WHILE n <> 0
        LET n = n \ 10
        LET count = count + 1
    END WHILE
    LET CountDigits = count
END SUB
```

`FOR` հրամանը սահմանում է նոր փոփոխական՝ _պարամետր_, տալիս է դրան սկզբնական արժեք և կատարում է ցիկլի մարմնի `Sequence` բլոկն այնքան ժամանակ, քանի դեռ պարամետրի արժեքը չի հավասարվել վերջնական արժեքին։ Եթե `STEP`-ը տրված չէ, ապա ամեն մի քայլում պարամետրի արժեքը փոխվում է 1-ով։

```
Statement = 'FOR' IDENT '=' Expression 'TO' Expression ['STEP' ['+'|'-'] NUMBER]
            Sequence 'END' 'FOR'.
```

Օրինակ, հետևյալ ծրագիրը հաշվում ու տպում է 20-ից մինչև 100 միջակայքի զույգ թվերի գումարը։

```basic
SUB Main
    LET sum = 0
    FOR i = 20 TO 100 STEP 2
        LET sum = sum + i
    END FOR
    PRINT sum
END SUB
```


__Ենթածրագրի կանչ։__ `CALL` հրամանը կանչում է տրված անունով ենթածրագիրը որպես հրաման, դրան փոխանցելով նշված արգումենտները; Բնականաբար, արգումենտների ցուցակը կարող է դատարկ լինել։ 

```
Statement = 'CALL' IDENT [ExpressionList].
```

Օրինակ, հետևյալ ծրագիրը կանչում է `PrintN` ենթածրագիրը՝ տրված արժեքը տրված քանակով տպելու համար։

```basic
SUB PrintN(value, number)
    WHILE number > 0
        PRINT value
        LET number = number - 1
    END WHILE
END SUB

SUB Main
    CALL PrintN "Ok", 4
    CALL PrintN "Yes", 2
END SUB
```

Նկատենք, որ ենթածրագրի կանչի դեպքում արգումենտները կլոր փակագծերի մեջ վերցնել պետք չէ։

Հրամանները սահմանված են իրենց քերականական հավասարումներով։ Այդ հավասարումների մեջ զանազան նպատակներով օգտագործեցինք `Expression`-ը՝ _արտահայտությունը_։ Առաջ անցնենք ու սահմանենք այն։

Գործողությունների զուգորդականությունն (assocaitivity) ու նախապատվությունը (priority) ճիշտ ապահովելու համար արտահայտությունների քերականական հավասարումները գրված են «մակարդակներով»։ Հետևյալ աղյուսակի տողերում գործողությունները դասավորված են ըստ նախապատվությունների աճման (վերևում՝ ամենացածր նախապատվություն ունեցողը).

| Գործողություն         | Իմաստ |
| :-------------------: | :--- | 
| `OR`                  | տրամաբանական ԿԱՄ |
| `AND`                 | տրամաբանական ԵՎ |
| `=`, `<>`             | հավասարություն, անհավասարություն |
| `<`,  `<=`, `>`, `>=` | համեմատումներ |
| `+`, `-`, `&`         | գումարում, հանում, տեքստերի կցում |
| `*`, `/`, `\`         | բազմապատկում, բաժանում, քանորդ |
| `^`                   | աստիճան բարձրացնել |
| `-`, `+`, `NOT`       | ունար մինուս, պլյուս, ժխտում |
| `[]`                  | զանգվածի տարր, ինդեքսավորում |

Ինչպես և մաթեմատիկայում, եթե պետք է արտահայտության որևէ մասի հաշվարկման նախապատվությունը բարձրացնել, ապա այդ մասը վերցվում է կլոր փակագծերի մեջ։ Օրինակ, `(3 + 4) * 5`:

Աղյուսակի ամեն մի տողի համար սահմանենք քերականական կանոն։ Սկսենք `OR` և `AND` տրամաբանական գործողություններից, որոնք ունեն ամենացածր նախապատվությունը։ Արտահայտությունը `OR` գործողությամբ իրար կապված կոնյունկցիաների շղթա է, իսկ կոնյունկցիան՝ իր հերթին, `AND` գործողությամբ իրար կապված համեմատությունների շղթա է։

```
Expression = Conjunction { 'OR' Conjunction }.
Conjunction = Equality { 'AND' Equality }.
```

Համեմատման գործողություններն էլ բաժանված են երկու մակարդակի. առաջինում հավասարության ու անհավասարության ստուգման գործողություններն են՝ `Equality` անունով, երկրորդում՝ համեմատման մյուս գործողությունները՝ `Comparison` անունով։ Սա, իհարկե, խիստ անհրաժեշտություն չէ, և շատ տեղերում էլ համեմատման բոլոր վեց գործողությունները սահմանվում են մեկ հավսարմամբ։ Այնուամենայնիվ, այսպիսի տրոհումը թույլ է տալիս գրել `5 > 4 = a >= b` տեսքի արտահայտություն և այն հասկանալ որպես `(5 > 4) = (a >= b)`։ Եթե բոլոր վեց գործողություններն էլ սահմանված լինեին նույն քերականական հավասարմամբ, ապա պարզապես ստիպված կլինեինք բացահայտ փակագծեր դնել։

```
Equality = Comparison [ ('=' | '<>') Comparison ].
Comparison = Addition [ ('<' | '<=' | '>' | '>=') Addition ].
```

Ադիտիվ գործողությունները երեքն են․ գումարում, հանում և տեքստերի կցում։ Մուլտիպլիկատիվ գործողություններն էլ երենք են․ բազմապատկում, բաժանում և մնացորդի որոշում։ Մուլտիպլիկատիվ գործողությունների նախապատվությունը մի ատիճանով բարձր է ադիտիվ գործողությունների նախապատվությունից։ Քանի որ տեքստերի միակցման `&` գործողությունն իր իմաստով ադիտիվ է, ես այն սահմանել եմ թվերի գումարման ու հանման գործողությունների շարքում։ Ահա դրանց հավասարումները.

```
Addition = Multiplication { ('+' | '-' | '&') Multiplication }.
Multiplication = Power { ('*' | '/' | '\') Power }.
```

Բոլոր այս երկտեղանի (բինար) գործողությունները _ձախ-զուգորդական_ են։ Դա նշանակում է, որ գործողությունների շղթաներ կազմելիս, օրինակ, `a - b - c - d`, հաշվարկները կատարվում են ձախից աջ՝ `((a - b) - c) - d` օրենքով։ Միակ _աջ-զուգորդական_ գործողությունը աստիճան բարձրացնելու գործողությունն է։ Դրա քերականական հավարարումն ուն մի փոքր այլ տեսք։ Այստեղ շղթան կազմվում է _ռեկուրսիայի_ միջոցով՝ աջից ձախ ուղղությամբ։

```
Power = Subscript [ '^' Power ].
```
 
Այս գործողության համար «աջ-զուգորդվող» նշանակում է, որ աստիճան բարձրացնելու գործողությամբ շղթաներ կազմելիս, օրինակ, `a^b^c^d`, հաշվարկները կատարվում են աջից ձախ՝ `a^(b^(c^d))` օրենքով, այլ ոչ թե ձախից աջ, ինչպես դա արվում է գումարման կամ բազմապատկման գործողությունների համար։

Միտեղանի (ունար) գործողությունները երեքն են․ ունար պլյուսը՝ երբ գրում ենք `+45` կամ `+a`, ունար մինուսը՝ երբ գրում ենք `-88` կամ `-x`, և տրամաբանական ժխտումը՝ երբ գրում ենք `NOT TRUE` կամ `NOT (a = b)`։ 

```
Unary = { '+' | '-' | 'NOT' } Subscript.
```

Բոլոր միտեղանի գործողությունները _աջ-զուգորդական_ են։ Դա նշանակում է, որ եթե միտեղանի գործողությունների շղթա կազմենք, օրինակ, `- - + NOT a`, ապա հաշվարկները կատարվելու են աջից ձախ՝ `-(-(+ (NOT a)))` օրենքով։

Վերջին գործողությունը, որ իր նախապատվությամբ ամենաբարձրն է, զանգվածի տարրին ինդեքսով դիմելու գործողությունն է։ Այն սահմանված է որպես բինար գործողություն, որի ձախ կողմում կարող է լինել ցանկացած պարզ արտահայտություն, որի հաշվարկման արդյունքը զանգված է, իսկ աջ կողմում պարզապես արտահայտություն է, որի հաշվարկումը պետք է վերադարձնի թվային արժեք։

```
Subscript = Factor { '[' Expression ']' }.
```

Արտահայտությունների քերականական մասի սահմանումն ավարտենք պարզագույն արտահայտությունների թվարկմամբ։ Դրանք են․ զանազան լիտերալները, փոփոխականները, ֆունկցիայի կանչը և խմբավորման փակագծերը։ Այդ ամենապարզ տարրերի խմբին քերականական հավասարումներում հաճախ անվանում են _Factor_։

```
Factor = 'TRUE' | 'FALSE' | NUMBER | TEXT | IDENT | IDENT '(' [ExpressionList] ')' | ArrayLiteral.
ExpressionList = Expression { ',' Expression }.
ArrayLiteral = '[' [ ExpressionList ] ']'.
```

Հետևյալները պարզագույն արտահայտությունների օրինակներ են.

```Basic
TRUE               ' «ճշմարիտ» արժեք
FALSE              ' «կեղծ» արժեք
3.1415             ' թիվ
777                ' թիվ 
"Սա տեքստ է։"      ' տեքստ
[1, 2, 3, 4]       ' զանգված
SIN(3.1415)        ' ֆունկցիայի կանչ
MID("Text", 2, 1)  ' ֆունկցիայի կանչ
```


Վերջում մի անգամ էլ, բայց արդեն ամբողջական տեսքը տեսնելու համար, բերենք Բալի քերականությունը․

```
Program = { Subroutine }.
Subroutine = 'SUB' IDENT ['(' [IdentList] ')'] Sequence 'END' 'SUB'.
IdentList = IDENT {',' IDENT}.
Sequence = NewLines { Statement NewLines }.
NewLines = NEWLINE { NEWLINE }.
Statement = 'DIM' IDENT '[' Expression ']'
          | 'INPUT' IDENT
          | 'PRINT' Expression
          | 'LET' IDENT ['[' Expression ']'] '=' Expression
          | 'IF' Expression 'THEN' Sequence
            { 'ELSEIF' Expression 'THEN' Sequence }
            [ 'ELSE' Sequence ]
            'END' 'IF'
          | 'WHILE' Expression Sequence 'END' 'WHILE'
          | 'FOR' IDENT '=' Expression 'TO' Expression ['STEP' ['+'|'-'] NUMBER]
             Sequence 'END' 'FOR'
          | 'CALL' IDENT [Expression {',' Expression}].
Expression = Conjunction { 'OR' Conjunction }.
Conjunction = Equality { 'AND' Equality }.
Equality = Comparison [ ('=' | '<>') Comparison ].
Comparison = Addition [ ('<' | '<=' | '>' | '>=') Addition ].
Addition = Multiplication { ('+' | '-' | '&') Multiplication }.
Multiplication = Power { ('*' | '/' | '\') Power }.
Power = Subscript [ '^' Power ].
Subscript = Factor { '[' Expression ']' }.
Factor = 'TRUE' | 'FALSE' | NUMBER | TEXT | IDENT | IDENT '(' [ExpressionList] ')' | ArrayLiteral.
ExpressionList = Expression { ',' Expression }.
ArrayLiteral = '[' [ ExpressionList ] ']'.
```


__Բառակազմությունը։__ Քերականական հավասարումներում `'` չակերտների մեջ վերցրած են _տերմինալային_ սիմվոլները։ Օրինակ, `SUB`, `TRUE` կամ `<>`։ Բալ ծրագրում դրանք հանդիպում են հենց նույն տեսքով որպես _ծառայողական բառեր_, _գործողություններ_ կամ _մետասիմվոլներ_։

Ծառայողական բառերն են. `SUB`, `END`, `DIM`, `INPUT`, `PRINT`, `LET`, `IF`, `THEN`, `ELSEIF`, `ELSE`, `WHILE`, `FOR`, `TO`, `STEP`, `CALL`, `OR`, `AND`, `NOT`, `TRUE`, `FALSE`։

`IDENT` սիմվոլով նշված են սովորական իդենտիֆիկատորները։ Դրանք կազմված են տառերից ու թվանշաններից, բայց, անպայմանորեն, սկսվում են տառով։ Օրինակ, `Main`, `maxOf`, `index2` և այլն։

`NUMBER` սիմվոլով որոշվում են իրական թվային հաստատունները։ Դրանք պետք է համապատասխանեն `[0-9]+(.[0-9]+)?` կանոնավոր արտահայտությանը։ Օրինակ, `8`, `3.1415`, `2025` և այլն։

`TEXT` սիմվոլով էլ որոշվում են տեքստային հաստատունները՝ վերցրած `"` չակերտների մեջ։
