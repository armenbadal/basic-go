# Ինտերպրետացիա

Ինտերպրետատորը վերլուծված ծրագրի աբստրակտ քերականական ծառը վերցնում է որպես մուտքային տվյալ և, հերթականությամբ այցելելով դրա հանգույցները՝ արմատից դեպի տերևները, յուրաքանչյուր հանգույցին կիրառում է իր տիպին համապատասխան հաշվարկող կամ ինտերպրետացնող ֆունկցիան։ Այդ ֆունկցիաներն իրականացված են որպես `interpreter` ստրուկտուրայի մեթոդներ։

`interpreter` ստրուկտուրան ունի երկու դաշտ. `program`, որը AST-ի արմատն է՝ ինտերպրետացվող ծրագիրը, և `env`, որը կատարման միջավայրն է՝ նախատեսված ծրագրի կատարման ընթացքում փոփոխականների արժեքները պահելու համար։

```Go
type interpreter struct {
	program *ast.Program // կատարվող ծրագրի ցուցիչը
	env     *environment // կատարման միջավայրը
}
```


## Հաշվարկման արժեք

Ինտերպրետացիայի թերևս առանցքային նշանակություն ունեցող էությունը _արժեքն_ է, որ այստեղ իրականացված է `value` ստրուկտուրայով։ Սա համապիտանի տիպ է, որը կարող է պահել չորս տիպի արժեքներ. տրամաբանական, թվային, տեքստային եւ զանգված։

```Go
type value struct {
	kind    rune     // տեսակը
	boolean bool     // տրամաբանական արժեք
	number  float64  // թվային արժեք
	text    string   // տեքստային արժեք
	array   []*value // արժեքների զանգված
}
```

Իսկ `kind` դաշտով որոշվում է, թե `value`-ի տվյալ նմուշն ի՛նչ տիպի արժեք է ներկայացնում։ Ահա հնարավոր տարբերակները.

```Go
const (
	vUndefined = '?' // անորոշ
	vBoolean   = 'B' // տեամաբանական
	vNumber    = 'N' // թվային
	vText      = 'T' // տեքստային
	vArray     = 'A' // զանգված
)
```

Ինտերպրետացիայի ընթացքում բոլոր միջանկյալ արժեքները ներկայացված են որպես `value` ստրուկտուրային նմուշներ։ Օրինակ, երբ ինտերպրետացվում է AST-ի `Boolean` տիպի հանգույցի `Boolean{Value: true}` նմուշը, ապա որպես արդյունք ստեղծվում է `value{kind: vBoolean, boolean: true}` նմուշը։

Մի այլ օրինակ. մաթեմատիկական _π_ հաստատունի համար պահվում է `value` ստրուկտուրայի `value{kind: vNumber, number: 3.1415}` նմուշը։


## Կատարման միջավայր

_Կատարման միջավայրն_ (_execution environment_) ըստ էության փոփոխականների տեսանելիության տիրույթների ստեկ է.

```Go
type environment struct {
	current *scope
}
```

_Տեսանելիության տիրույթը_ (_scope_) փոփոխականների անուններն արտապատկերում է դրանց ընթացիկ արժեքներին։ Այս ստրուկտուրան ցուցիչ է պարունակում նաև ընթացիկ scope-ին ընդգրկող scope—ին։

```Go
type scope struct {
	items map[string]*value // փոփոխականների ընթացիկ արժեքներ
	up    *scope            // ընդգրկող scope-ի ցուցիչ
}
```

Նոր տիրույթը ստեղծվում է `openScope` մեթոդով, իսկ ընթացիկ տիրույթը «փակվում» է, դեն է նետվում `closeScope` մեթոդով։

```Go
func (e *environment) openScope() {
	e.current = &scope{
		items: make(map[string]*value),
		up:    e.current,
	}
}

func (e *environment) closeScope() {
	if e.current != nil {
		e.current = e.current.up
	}
}
```

Կատարման միջավայրի ընթացիկ տեսանլիության տիրույթում նոր փոփոխական-արժեք զույգ ավելացնելու համար օգտագործվում է `set` մեթոդը։

```Go
func (e *environment) set(name string, value *value) {
	if e.current != nil {
		e.current.items[name] = value
	}
}
```

Տրված անունով փոփոխականի արժեքը կատարման միջավայրից ստանալու համար է նախատեսված `get` մեթոդը։

```Go
func (e *environment) get(name string) *value {
	for p := e.current; p != nil; p = p.up {
		if v, exists := p.items[name]; exists {
			return v
		}
	}

	return nil
}
```


## Ենթածրագրի կանչ կամ կիրառություն

Քանի որ Բալ ծրագրի կատարումը սկսվում է `Main` ենթածրագրից, 
Ենթածրագիր-ֆունկցիայի կիրառման `Apply` և կանչի `Call` հանգույցները նույնն են։ Ու քանի որ արդեն խոսք գնաց `Main` ենթածրագիր կատարման մասին, տեսնենք թե ինչպես է հաշվարկվում ֆունկցիայի կիրառությունը.


## Ծրագրի կատարում

Ծրագրի կատարումը սկսվում է `interpreter` փաթեթից արտահանված միակ `Execute(p *ast.Program)` ֆունկցիայով։ Այս ֆունկցիան աշխատում է հետևյալ քայլերով.
1. իրեն փոխանցված ցուցիչը վերագրում է `program` գլոբալ փոփոխականին, որից հետո հարցվելու են օգտագործողի սահմանած ենթածրագրերը,
2. ստեղծվում է կատարման միջավայրի օբյեկտը և դրանում ավելացվում է նոր տեսանելիության տիրույթ (scope),
3. ստեղծում է `Call` օբյեկտ՝ `Main` անունով և արգումենտների դատարկ ցուցակով,
4. `execute()` ֆունկցիայով կատարում է `Call` օբյեկտը, 
5. և վերջում հեռացնում է կատարման միջավայրի վերջին տեսանլիության տիրույթը։

Եթե 4-րդ քայլը կատարելիս որևէ սխալ է տեղի ունենում, ապա համապատասխան հաղորդագրությունն արտածվում է `Execute()` ֆունկցիայի սկզբում, `defer` հրամանով հետաձգված ֆունկցիայի ??

```Go
func Execute(p *ast.Program) {
	// ․․․
}
```



## Արտահայտությունների հաշվարկում

Ինչպես արդեն տեսանք աբստրակտ քերականական ծառի նկարագրության գլխում, արտահայտությունների տարատեսակները ներկայացնող հանգույցների տիպերն ութն են. `Boolean`, `Number`, `Text` և `Array` — լիտերալների համար, `Unary` և `Binary` — միտեղանի ու երկտեղանի գործողությունների համար և `Apply` — ենթածրագիր-ֆունկցիաների կիրառության համար։ Արտահայտության տրված ենթածառի տիպը տարբերակվում և համապատասխան հաշվարկող ֆունկցիան կանչվում է `evaluate` ֆունկցիայում.

```Go
func evaluate(n ast.Node, env *environment) *value {
	var result *value

	switch e := n.(type) {
	case *ast.Boolean:
		result = evaluateBoolean(e, env)
	case *ast.Number:
		result = evaluateNumber(e, env)
	case *ast.Text:
		result = evaluateText(e, env)
	case *ast.Array:
		result = evaluateArray(e, env)
	case *ast.Variable:
		result = evaluateVariable(e, env)
	case *ast.Unary:
		result = evaluateUnary(e, env)
	case *ast.Binary:
		result = evaluateBinary(e, env)
	case *ast.Apply:
		result = evaluateApply(e, env)
	}

	return result
}
```

## Հրամանների կատարում
