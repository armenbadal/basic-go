# Ինտերպրետացիա

Ինտերպրետատորը վերլուծված ծրագրի աբստրակտ քերականական ծառը վերցնում է որպես մուտքային տվյալ և, հերթականությամբ այցելելով դրա հանգույցները՝ արմատից դեպի տերևները, յուրաքանչյուր հանգույցին կիրառում է իր տիպին համապատասխան հաշվարկող կամ ինտերպրետացնող ֆունկցիան։ Այդ ֆունկցիաներն իրականացված են որպես `Interpreter` ստրուկտուրայի մեթոդներ։

`Interpreter` ստրուկտուրան ունի երկու դաշտ. `program`, որը AST-i արմատն է՝ ինտերպրետացվող ծրագիրը, և `env`, որը կատարման միջավայրն է՝ նախատեսված ծրագրի կատարման ընթացքում փոփոխականների արժեքները պահելու համար։

```Go
type Interpreter struct {
	program *ast.Program // կատարվող ծրագրի ցուցիչը
	env     *environment // կատարման միջավայրը
}
```

## Կատարման միջավայր

_Կատարման միջավայրն_ (_execution environment_) ըստ էության փոփոխականների տեսանելիության տիրույթների ստեկ է.

```Go
type environment struct {
	current *scope
}
```

_Տեսանելիության տիրույթը_ (_scope_) փոփոխականների անուններն արտապատկերում է դրանց ընթացիկ արժեքներին։ Այս ստրուկտուրան ցուցիչ է պարունակում նաև ընթացիկ scope-ին ընդգրկող scope—ին։

```Go
type scope struct {
	items map[string]*value // փոփոխականների ընթացիկ արժեքներ
	up    *scope            // ընդգրկող scope-ի ցուցիչ
}
```

Նոր տիրույթը ստեղծվում է `openScope` մեթոդով, իսկ ընթացիկ տիրույթը «փակվում» է, դեն է նետվում `closeScope` մեթոդով։

```Go
func (e *environment) openScope() {
	e.current = &scope{
		items: make(map[string]*value),
		up:    e.current,
	}
}

func (e *environment) closeScope() {
	if e.current != nil {
		e.current = e.current.up
	}
}
```

Կատարման միջավայրի ընթացիկ տեսանլիության տիրույթում նոր փոփոխական-արժեք զույգ ավելացնելու համար օգտագործվում է `set` մեթոդը։

```Go
func (e *environment) set(name string, value *value) {
	if e.current != nil {
		e.current.items[name] = value
	}
}
```

Տրված անունով փոփոխականի արժեքը 


## Ենթածրագրի կանչ կամ կիրառություն

Քանի որ Բալ ծրագրի կատարումը սկսվում է `Main` ենթածրագրից, 
Ենթածրագիր-ֆունկցիայի կիրառման `Apply` և կանչի `Call` հանգույցները նույնն են։ Ու քանի որ արդեն խոսք գնաց `Main` ենթածրագիր կատարման մասին, տեսնենք թե ինչպես է հաշվարկվում ֆունկցիայի կիրառությունը.

```Go
```


## Հաշվարկման արժեք

Ինտերպրետացիայի թերևս առանցքային նշանակություն ունեցող էությունը _արժեքն_ է, որ այստեղ իրականացված է `value` ստրուկտուրայով։ Սա համապիտանի տիպ է, որը կարող է պահել չորս տիպի արժեքներ. տրամաբանական, թվային, տեքստային եւ զանգված։ Ինտերպրետացիայի ընթացքում բոլոր միջանկյալ արժեքները ներկայացված են որպես `value` ստրուկտուրային նմուշներ։ Օրինակ, երբ ինտերպրետացվում է AST-ի `Boolean` տիպի հանգույցի `Boolean{Value: true}` նմուշը, ապա որպես արդյունք ստեղծվում է `value{}`

Բոլոր տեսակի արտահայտությունների հաշվարկման արդյունքում ստացվում է `value` տիպի արժեք.

```Go
type value struct {
	kind    rune     // տեսակը
	boolean bool     // տրամաբանական արժեք
	number  float64  // թվային արժեք
	text    string   // տեքստային արժեք
	array   []*value // արժեքների զանգված
}
```

Այս ստրուկտուրային `kind` դաշտով է որոշվում, թե `value`-ի տվյալ նմուշն ի՛նչ տիպի արժեք է ներկայացնում։ Ահա հնարավոր տարբերակները.

```Go
const (
	vUndefined = '?' // անորոշ
	vBoolean   = 'B' // տեամաբանական
	vNumber    = 'N' // թվային
	vText      = 'T' // տեքստային
	vArray     = 'A' // զանգված
)
```

Օրինակներ.

```Go
b0 := &value{kind: vBoolean, boolean: true} // տրամաբանական արժեք
n0 := &value{kind: vNumber, number: 3.1415} // թվային արժեք
```


## Ծրագրի կատարում

Ծրագրի կատարումը սկսվում է `interpreter` փաթեթից արտահանված միակ `Execute(p *ast.Program)` ֆունկցիայով։ Այս ֆունկցիան աշխատում է հետևյալ քայլերով.
1. իրեն փոխանցված ցուցիչը վերագրում է `program` գլոբալ փոփոխականին, որից հետո հարցվելու են օգտագործողի սահմանած ենթածրագրերը,
2. ստեղծվում է կատարման միջավայրի օբյեկտը և դրանում ավելացվում է նոր տեսանելիության տիրույթ (scope),
3. ստեղծում է `Call` օբյեկտ՝ `Main` անունով և արգումենտների դատարկ ցուցակով,
4. `execute()` ֆունկցիայով կատարում է `Call` օբյեկտը, 
5. և վերջում հեռացնում է կատարման միջավայրի վերջին տեսանլիության տիրույթը։

Եթե 4-րդ քայլը կատարելիս որևէ սխալ է տեղի ունենում, ապա համապատասխան հաղորդագրությունն արտածվում է `Execute()` ֆունկցիայի սկզբում, `defer` հրամանով հետաձգված ֆունկցիայի ??

```Go
func Execute(p *ast.Program) {
	// ․․․
}
```



## Արտահայտությունների հաշվարկում

Ինչպես արդեն տեսանք աբստրակտ քերականական ծառի նկարագրության գլխում, արտահայտությունների տարատեսակները ներկայացնող հանգույցների տիպերն ութն են. `Boolean`, `Number`, `Text` և `Array` — լիտերալների համար, `Unary` և `Binary` — միտեղանի ու երկտեղանի գործողությունների համար և `Apply` — ենթածրագիր-ֆունկցիաների կիրառության համար։ Արտահայտության տրված ենթածառի տիպը տարբերակվում և համապատասխան հաշվարկող ֆունկցիան կանչվում է `evaluate` ֆունկցիայում.

```Go
func evaluate(n ast.Node, env *environment) *value {
	var result *value

	switch e := n.(type) {
	case *ast.Boolean:
		result = evaluateBoolean(e, env)
	case *ast.Number:
		result = evaluateNumber(e, env)
	case *ast.Text:
		result = evaluateText(e, env)
	case *ast.Array:
		result = evaluateArray(e, env)
	case *ast.Variable:
		result = evaluateVariable(e, env)
	case *ast.Unary:
		result = evaluateUnary(e, env)
	case *ast.Binary:
		result = evaluateBinary(e, env)
	case *ast.Apply:
		result = evaluateApply(e, env)
	}

	return result
}
```

## Հրամանների կատարում
