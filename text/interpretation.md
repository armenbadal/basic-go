# Ինտերպրետացիա

Ինչպես լեզվի շարահյուսական վերլուծությունն է կառուցված ռեկուրսիվ ֆունկցիաներով,որոնցից ամեն մեկը վերլուծում է քերականության «իրեն հասանելիք» հատվածը և վերադարձնում է աբստրակտ քերականական ծառի մի ենթածառ, այնպես էլ ինտերպրետատորն է կառուցված ռեկուրսիվ ֆունկցիաներով, որոնցից յուրաքանչյուրը կատարում կամ հաշվարկում է ծառի՝ իրեն վերաբերող ենթածառը։

Ինտերպրետացիան իրականացված է `interpreter` փաթեթում։ Այս փաթեթում են ներառված թե՛ առանձին հանգույցների ինտերպրետացաիյի ֆունկցիաները, թե՛ կատարման միջավայրի իրականացումը, թե՛ ներդրված ենթածրագրերի սահմանումները և թե՛ հաշվարկման ունիվերսալ արժեքի սահմանումը։ 

## Հաշվարկման արժեք

Բոլոր տեսակի արտահայտությունների հաշվարկման արդյունքում ստացվում է `value` տիպի արժեք.

```Go
type value struct {
	kind    rune     // տեսակը
	boolean bool     // տրամաբանական արժեք
	number  float64  // թվային արժեք
	text    string   // տեքստային արժեք
	array   []*value // արժեքների զանգված
}
```

Այս ստրուկտուրային `kind` դաշտով է որոշվում, թե `value`-ի տվյալ նմուշն ի՛նչ տիպի արժեք է ներկայացնում։ Ահա հնարավոր տարբերակները.

```Go
const (
	vUndefined = '?' // անորոշ
	vBoolean   = 'B' // տեամաբանական
	vNumber    = 'N' // թվային
	vText      = 'T' // տեքստային
	vArray     = 'A' // զանգված
)
```

Օրինակներ.

```Go
b0 := &value{kind: vBoolean, boolean: true} // տրամաբանական արժեք
n0 := &value{kind: vNumber, number: 3.1415} // թվային արժեք
```

## Կատարման միջավայր

Ծրագիր ինտերպրետացիայի ընթացքում հաշվարկված արժեքները պահվում են `environment` տիպի օբյեկտում։ Սա հենց _կատարման միջավայրն_ է (execution environment)։ 

```Go
type scope struct {
	items map[string]*value
	up    *scope
}

type environment struct {
	current *scope
}
```

Տեսնում ենք, որ `environment`-ը `scope`-երի՝ _տեսանելիության տիրույթների_ ստեկ է, որի «գագաթին» ցույց է տալիս `current` ցուցիչը։ Նոր տիրույթը ստեղծվում է `openScope` մեթոդով, իսկ ընթացիկ տիրույթը փակվում է, դեն է նետվում `closeScope` մեթոդով։

```Go
func (e *environment) openScope() {
	e.current = &scope{
		items: make(map[string]*value),
		up:    e.current,
	}
}

func (e *environment) closeScope() {
	if e.current != nil {
		e.current = e.current.up
	}
}
```

Կատարման միջավայրի ընթացիկ տեսանլիության տիրույթում նոր փոփոխական-արժեք զույգ ավելացնելու համար օգտագործվում է `set` մեթոդը։

```Go
func (e *environment) set(name string, value *value) {
	e.current.items[name] = value
}
```

Տրված անունով փոփոխականի արժեքը 

## Ծրագրի կատարում

Ծրագրի կատարումը սկսվում է `interpreter` փաթեթից արտահանված միակ `Execute(p *ast.Program)` ֆունկցիայով։ Այս ֆունկցիան աշխատում է հետևյալ քայլերով.
1. իրեն փոխանցված ցուցիչը վերագրում է `program` գլոբալ փոփոխականին, որից հետո հարցվելու են օգտագործողի սահմանած ենթածրագրերը,
2. ստեղծվում է կատարման միջավայրի օբյեկտը և դրանում ավելացվում է նոր տեսանելիության տիրույթ (scope),
3. ստեղծում է `Call` օբյեկտ՝ `Main` անունով և արգումենտների դատարկ ցուցակով,
4. `execute()` ֆունկցիայով կատարում է `Call` օբյեկտը, 
5. և վերջում հեռացնում է կատարման միջավայրի վերջին տեսանլիության տիրույթը։

Եթե 4-րդ քայլը կատարելիս որևէ սխալ է տեղի ունենում, ապա համապատասխան հաղորդագրությունն արտածվում է `Execute()` ֆունկցիայի սկզբում, `defer` հրամանով հետաձգված ֆունկցիայի ??

```Go
func Execute(p *ast.Program) {
	// ․․․
}
```

## Ենթածրագրի կանչ կամ կիրառություն

Ենթածրագիր-ֆունկցիայի կիրառման `Apply` և կանչի `Call` հանգույցները նույնն են։ Ու քանի որ արդեն խոսք գնաց `Main` ենթածրագիր կատարման մասին, տեսնենք թե ինչպես է հաշվարկվում ֆունկցիայի կիրառությունը.

```Go
```


## Արտահայտությունների հաշվարկում

Ինչպես արդեն տեսանք աբստրակտ քերականական ծառի նկարագրության գլխում, արտահայտությունների տարատեսակները ներկայացնող հանգույցների տիպերն ութն են. `Boolean`, `Number`, `Text` և `Array` — լիտերալների համար, `Unary` և `Binary` — միտեղանի ու երկտեղանի գործողությունների համար և `Apply` — ենթածրագիր-ֆունկցիաների կիրառության համար։ Արտահայտության տրված ենթածառի տիպը տարբերակվում և համապատասխան հաշվարկող ֆունկցիան կանչվում է `evaluate` ֆունկցիայում.

```Go
func evaluate(n ast.Node, env *environment) *value {
	var result *value

	switch e := n.(type) {
	case *ast.Boolean:
		result = evaluateBoolean(e, env)
	case *ast.Number:
		result = evaluateNumber(e, env)
	case *ast.Text:
		result = evaluateText(e, env)
	case *ast.Array:
		result = evaluateArray(e, env)
	case *ast.Variable:
		result = evaluateVariable(e, env)
	case *ast.Unary:
		result = evaluateUnary(e, env)
	case *ast.Binary:
		result = evaluateBinary(e, env)
	case *ast.Apply:
		result = evaluateApply(e, env)
	}

	return result
}
```

## Հրամանների կատարում
