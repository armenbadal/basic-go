# Վերլուծության ծառ

_Աբստրակտ քերականական ծառը_ (այսուհետ՝ _քերականական ծառ_ կամ պարզապես _ծառ_) այն օբյեկտն է, որը կառուցվում է ծրագրի շարահյուսական վերլուծության արդյունքում որպես ծրագրի ժամանակավոր, միջանկյալ ներկայացում։ Ինտերպրետատորի իրականացման դեպքում այս ծառն օգտագործվում է _հաշվարկման_ համար (իսկ կոմպիլյատորի իրականացման դեպքում այս ծառից գեներացվում է կոնկրետ պլատֆորմի նպատակային կոդ)։

Քերականական ծառը ճիշտ կառուցելու համար լեզվի քերականության յուրաքանչյուր ինքնուրույն տարրի համար պետք է սահմանել համապատասխան ստրուկտուրա (տիպ)։ Այսպես, ծառում _ծրագիրը_ պետք է ունենա ի՛ր հանգույցը, _ենթածրագիրն_՝ իր, _հրամաններն_ ու _արտահայտություններն_՝ իրենցը, և այլն։ Այդ հանգույցների տեսքը դուրս է բերվում անմիջապես քերականական հավասարումից։ 


## Ծրագիր

Լեզվի քերականությունը սահմանելիս ծրագրի համար գրեցի հետևյալ հավասարումը.

```
Program = { Subroutine }.
```

Ըստ այսմ կարող եմ `Program` ստրուկտուրան սահմանել որպես ենթածրագրերի ցուցակ։ Իսկ, որ ավելի հարմար է, ենթածրագրերի անունը օբյեկտին համապատասխանեցնող արտապատկերում.

```Go
type Program struct {
	Subroutines map[string]*Subroutine // ենթածրագրեր
}
```

Ցուցակի փոխարեն `map` պահելը մեզ հնարավորություն է տալու վերլուծության ու ինտերպրետացիայի ժամանակ ավելի քիչ գործողություններ կատարելով գտնել կանչվող ենթածրագիրը (կիրառվող ֆունկցիան), ինչպես նաև՝ հայտնաբերել վերլուծության ու իմաստային սխալները։


## Ենթածրագիր

Ենթածրագիրը ներկայացնող հանգույցի ստրուկտուրան, թերևս, սպասվածից էլ պարզ է. այն պարունակում է  անունը, պարամետրերի ցուցակը և մարմնի ենթածառը։

```Go
type Subroutine struct {
	Name       string    // անուն
	Parameters []string  // պարամետրեր
	Body       Statement // մարմին
}
```


## Հրամաններ

`Statement`-ը Բալի հրամանների ինտերֆեյսն է և սահմանված է հետևյալ կերպ.

```Go
type Statement any
```

Այնուհետև առանձին-առանձին սահմանված են Բալ լեզվի ութ հրամանները ներկայացնող հանգույցները։


### Զանգվածի սահմանում

Զանգվածների սահմանման `DIM` հրամանի համար սահմանված հանգույցի տիպը պարունակում է զանգվածի անունն ու տարրերի քանակը։

```Go
type Dim struct {
	Name string     // անունը
	Size Expression // չափը
}
```

Չափն արտահայտված է արտահայտությամբ՝ `Expression`, որպեսզի կատարման ժամանակ հնարավորություն ունենանք ստեղծելու և օգտագործելու դինամիկ զանգվածներ։


### Վերագրում

Վերագրման `LET` հրամանի `Place` դաշտով որոշվում է այն տեղը, որին պիտի վերագրել `Value` դաշտից հաշվարկած արժեքը։

```Go
type Let struct {
	Place Expression  // վերագրման տեղը
	Value Expression  // վերագրվող արժեքը
}
```

Վերագրման տեղը՝ `Place` կարող էր լինել պարզապես փոփոխական՝ `Variable`, բայց դա մի քիչ կդժվարացներ զանգվածի տարրերին արժեք վերագրելու գործողությունը։ Երբ սա արտահայտություն է, իսկ զանգվածի տարրին դիմելն էլ մոդելավորված է որպես երկտեղանի (բինար) գործողություն, ապա վերագրելիս պետք է հաշվարկել `Place`-ը, գտնել վերագրման ճիշտ տեղը, ապա դրան վերագրել `Value`-ի հաշվարկված արժեքը։


### Ներմուծում

Ներմուծման հրամանի հանգույցի տիպում միայն այն տեղի հղումն է, որտեղ պետք է պահել ներմուծված արժեքը։ Այստեղ էլ `Place՝-ը նույն նպատակով է արտահայտություն, ինչպես վերագրման հրանանի դեպքում։

```Go
type Input struct {
	Place Expression  // արժեքը պահելու տեղը
}
```


### Արտածում

Արտածման հրամանի հանգույցում էլ արտածվող արժեքը ներկայացնող արտահայտության ենթածառն է։

```Go
type Print struct {
	Value Expression  // արտածվելիք արժեք
}
```


### Պայման կամ ճյուղավորում

Պայմանի կամ ճյուղավորման հրամանը ներկայացնող հանգույցի տիպն ունի երեք դաշտ՝ պայմանի, դրական ու բացասական ընտրությունների ենթածառերի համար։

```Go
type If struct {
	Condition   Expression  // պայման
	Decision    Statement   // դրական ընտրություն
	Alternative Statement   // բացասական ընտրություն
}
```

Սա այն միակ դեպքն է, երբ ծառի հանգույցի ստրուկտուրան ուղղակիորեն չի արտացոլում քերականական կանոնը։ Եթե հետևենք նախորդ գլխում ճյուղավորման հրամանի համար սահմանված քերականական կանոնին, ապա `If` ստրուկտուրան պետք կլիներ սահմանել հետևյալ կերպ.

```Go
type If struct {
	FirstBranch    *IfThen     // IF հիմնական ճյուղը
	ElseIfBranches []*IfThen   // ELSEIF ճյուղերը
	Alternative    Statement   // ELSE ճյուղը
}

type IfThen struct {
	Condition Exression  // պայմանի արտահայտությունը
	Decision Statement   // կատարվող բլոկը
}
```

Գուցե սա ավելի ճիշտ կլիներ մյուս ստրուկտուրաների հետ համանմանության տեսակետից, սակայն իրականացման համար ընտրել ենք առաջին, ավելի պարզ դեպքը։


### Նախապայմանով ցիկլ

Նախապայմանով ցիկլի նկարագրման `While` տիպը հղումներ է պարունակում ցիկլի կատարման պայմանի ու մարմնի ենթածառերին։

```Go
type While struct {
	Condition Expression  // կատարման պայման
	Body      Statement   // մարմին
}
```


### Պարամետրով ցիկլ

Պարամետրով ցիկլը ներկայացնող հանգույցի `For` ստրուկտուրան.

```Go
type For struct {
	Parameter Expression  // հաշվիչը
	Begin     Expression  // հաշվիչի սկզբնական արժեք
	End       Expression  // հաշվիչի վերջնական արժեք
	Step      Expression  // հաշվիչի քայլը
	Body      Statement   // մարմինը
}
```


### Ենթածրագրի կանչ

Ենթածրագրի կանչի `CALL` հրամանի համար օգտագործում եմ ենթածրագիր-ֆունկցիայի կիրառման հանգույցի `Apply` տիպը (տե՛ս ստորև)։

```Go
type Call = Apply
```


### Հրամանների հաջորդում

Եվ վերջապես, հրամանների հաջորդականության հանգույցի տիպը, որը պարզապես պարունակում է հրամանների ենթածառերի ցուցակը։

```Go
type Sequence struct {
	Items []Statement // հրամաններ
}
```


## Արտահայտություններ

Արտահայտությունների `Expression` ինտերֆեյսը, որ արդեն օգտագործել ենք հրամանների հանգույցների ստրուկտուրաները սահմանելիս, սահմանված է հրամանների `Statement` ինտերֆեյսի պես։

```Go
type Expression any
```

Ուշադիր նայելով լեզվի քերականությանը՝ կտեսնենք, որ արտահայտությունները չորս տեսակի են. տարբեր տիպերի լիտերալներ, ունար գործողության կիրառություն, բինար գործողության կիրառություն և ֆունկցիա-ենթածրագրի կիրառություն։ 


### Լիտերալներ

Ստրուկտուրաներ (հանգույցների տիպեր) սահմանեմ այդ տիպերի համար։

```Go
// Բուլյան լիտերալ
type Boolean struct {
	Value bool // տրամաբանական հաստատուն
}

// Թվային լիտերալ
type Number struct {
	Value float64 // թվային հաստատուն
}

// Տեքստային լիտերալ
type Text struct {
	Value string // տեքստային հաստատուն
}

// Փոփոխական
type Variable struct {
	Name string // փոփոխականի անունը
}
```

Զանգվածի լիտերալի ներկայացման համար `Array` հանգույցն է, որի `Elements` դաշտը `Expression`-երի ցուցակ է.

```Go
type Array struct {
	Elements []Expression  // զանգվածի տարրերը
}
```


### Միտեղանի գործողություն

Միտեղանի (ունար, unary) գործողությունների համար սահմանված է `Unary` ստրուկտուրան։ Այստեղ գործողության անունն է և ենթաարտահայտության ծառը.

```Go
type Unary struct {
	Operation string      // գործողությունը
	Right     Expression  // արգումենտը
}
```


### Երկտեղանի գործողություն

Երկտեղանի գործողության `Binary` ստրուկտուրայում արդեն երկու ենթաարտահայտությունների ծառեր են՝ գործողության ձախ ու աջ արգումենտներին համապատասխան.

```Go
type Binary struct {
	Operation string      // գործողությունը
	Left      Expression  // ձախ արգումենտը
	Right     Expression  // աջ արգումենտնը
}

```


### Ֆունկցիայի կիրառում

Արտահայտություններում ֆունկցիա-ենթածրագրերի կիրառությունը ներկայացնելու համար սահմանված է `Apply` հանգույցը, որի `Callee` դաշտը կիրառվելիք ենթածրագրի անունն է, իսկ `Arguments` զանգվածը՝ կիրառման արգումենտների ցուցակը։ 

```Go
type Apply struct {
	Callee    string        // ենթածրագրի անուն
	Arguments []Expression  // արգումենտների ցուցակ
}
```

