# Ինտերպրետացիա

Ինտերպրետատորը վերլուծված ծրագրի աբստրակտ քերականական ծառը վերցնում է որպես մուտքային տվյալ և, հերթականությամբ այցելելով դրա հանգույցները՝ արմատից դեպի տերևները, յուրաքանչյուր հանգույցին կիրառում է իր տիպին համապատասխան հաշվարկող կամ ինտերպրետացնող ֆունկցիան։ Այդ ֆունկցիաներն իրականացված են որպես `interpreter` ստրուկտուրայի մեթոդներ։ Ակնհայտորեն այստեղ օգտագործված է _visitor_ կաղապարը։

`interpreter` ստրուկտուրան ունի երկու դաշտ. `program`, որը AST-ի արմատն է՝ ինտերպրետացվող ծրագիրը, և `env`, որը կատարման միջավայրն է՝ նախատեսված ծրագրի կատարման ընթացքում փոփոխականների արժեքները պահելու համար։

```Go
type interpreter struct {
	program *ast.Program // կատարվող ծրագրի ցուցիչը
	env     *environment // կատարման միջավայրը
}
```

`program`-ի կառուցվածքի մասին արդեն խսել ենք [Վերլուծության ծառ](ch03_astree.md) գլխում։ Հիմա տեսնենք, թե ինչպես է կառուցված _կատարման միջավայրը_ և ինչպես է իրականացնում իրեն վերապահված գործողությունները։


## Կատարման միջավայր

`environment` ստրուկտուրայով իրականացված _կատարման միջավայրն_ (_execution environment_) ըստ էության փոփոխականների տեսանելիության տիրույթների ստեկ է.

```Go
type environment struct {
	current *scope
}
```

Այստեղ `current` դաշտը, այն է՝ փոփոխականների՝ տվյալ պահին ակտիվ տեսանելիության տիրույթը, ստեկի սկզբունքով իրար կապված տեսանելիության տիրույթներից վերջինն է՝ ստեկի գագաթը։

_Տեսանելիության տիրույթը_ (_scope_) փոփոխականների անուններն արտապատկերում է դրանց ընթացիկ արժեքներին. `items` դաշտը `map` օբյեկտով համապատասխանության մեջ է դնում փոփոխականի անունն իր ընթացիկ արժեքին։ Այս ստրուկտուրան ցուցիչ է պարունակում նաև ընթացիկ տիրությին ընդգրկող տիրույթին (`up`)՝ ապահովելով փոփոխականի որոնումը տիրույթների ամբողջ շղթայով։

```Go
type scope struct {
	items map[string]*value // փոփոխականների ընթացիկ արժեքներ
	up    *scope            // ընդգրկող scope-ի ցուցիչ
}
```

Դիտարկենք հետևյալ ոչ մեծ օրինակը.

```basic
SUB Main
  LET x = pi
  PRINT x

  FOR i = 1 TO 4
    LET y = i * 2
    PRINT y
  END FOR

  LET n = 2
  WHILE n <> 0
    LET y = n^2
    PRINT y
	LET n = n - 1
  END WHILE
END SUB
```

Այստեղ կա չորս տեսանելիության տիրույթ. առաջինը _գլոբալն_ է, որտեղ դեռ միայն `pi` հաստատունի արժեքն է, երկրորդը ենթածրագրի մարմինն է, որում սահմանվում են `x` և `n` փոփոխականները, երրորդը `FOR` հրամանի մարմինն է, որում սահմանվում են `i` և `y` փոփոխականները, չորրորդը `WHILE` հրամանի մարմինն է, որում սահմանվում է `y` փոփոխականը։ `FOR` և `WHILE` հրամանների մարմիններում սահմանված `y`-ները լիովին անկախ ու տարբեր են։

Ինտերպրետացիայի ժամանակ նոր տիրույթը ստեղծվում է `openScope` մեթոդով, իսկ ընթացիկ տիրույթը «փակվում» է, դեն է նետվում `closeScope` մեթոդով։

```Go
func (e *environment) openScope() {
	e.current = &scope{
		items: make(map[string]*value),
		up:    e.current,
	}
}

func (e *environment) closeScope() {
	if e.current != nil {
		e.current = e.current.up
	}
}
```

Կատարման միջավայրի ընթացիկ տեսանլիության տիրույթում նոր փոփոխական-արժեք զույգ ավելացնելու համար օգտագործվում է `set` մեթոդը։

```Go
func (e *environment) set(name string, value *value) {
	if e.current != nil {
		e.current.items[name] = value
	}
}
```

Տրված անունով փոփոխականի արժեքը կատարման միջավայրից ստանալու համար է նախատեսված `get` մեթոդը։

```Go
func (e *environment) get(name string) *value {
	for p := e.current; p != nil; p = p.up {
		if v, exists := p.items[name]; exists {
			return v
		}
	}

	return nil
}
```


## Հաշվարկման արժեք

Ինտերպրետացիայի առանցքային նշանակություն ունեցող էությունը _արժեքն_ է, որ այստեղ իրականացված է `value` ստրուկտուրայով։ Սա համապիտանի տիպ է, որը կարող է պահել չորս տիպի արժեքներ. _տրամաբանական_, _թվային_, _տեքստային_ եւ նույն այդ տիպերի _զանգված_։

```Go
type value struct {
	kind    rune     // տեսակը
	boolean bool     // տրամաբանական արժեք
	number  float64  // թվային արժեք
	text    string   // տեքստային արժեք
	array   []*value // արժեքների զանգված
}
```

Սրա `kind` դաշտով որոշվում է, թե `value`-ի տվյալ նմուշն ի՛նչ տիպի արժեք է ներկայացնում։ Ահա հնարավոր տարբերակները.

```Go
const (
	vUndefined = '?' // անորոշ
	vBoolean   = 'B' // տեամաբանական
	vNumber    = 'N' // թվային
	vText      = 'T' // տեքստային
	vArray     = 'A' // զանգված
)
```

Ինտերպրետացիայի ընթացքում բոլոր միջանկյալ արժեքները ներկայացված են որպես `value` ստրուկտուրային նմուշներ։ Օրինակ, երբ ինտերպրետացվում է, հաշվարկվում է AST-ի `Boolean` տիպի հանգույցի `Boolean{Value: true}` նմուշը, ապա արդյունքում ստեղծվում է `value{kind: vBoolean, boolean: true}` նմուշը։


## Ծրագրի կատարում

Ծրագրի կատարումը սկսվում է `interpreter` փաթեթից արտահանված միակ `Execute(p *ast.Program)` ֆունկցիայով։ Այս ֆունկցիան աշխատում է հետևյալ քայլերով.
1. իրեն փոխանցված ցուցիչը վերագրում է `program` գլոբալ փոփոխականին, որից հետո հարցվելու են օգտագործողի սահմանած ենթածրագրերը,
2. ստեղծվում է կատարման միջավայրի օբյեկտը և դրանում ավելացվում է նոր տեսանելիության տիրույթ (scope),
3. ստեղծում է `Call` օբյեկտ՝ `Main` անունով և արգումենտների դատարկ ցուցակով,
4. `execute()` ֆունկցիայով կատարում է `Call` օբյեկտը, 
5. և վերջում հեռացնում է կատարման միջավայրի վերջին տեսանլիության տիրույթը։

Եթե 4-րդ քայլը կատարելիս որևէ սխալ է տեղի ունենում, ապա համապատասխան հաղորդագրությունն արտածվում է `Execute()` ֆունկցիայի սկզբում, `defer` հրամանով հետաձգված ֆունկցիայի ??

```Go
func Execute(p *ast.Program) {
	// ․․․
}
```



## Արտահայտությունների հաշվարկում

Ինչպես արդեն տեսանք աբստրակտ քերականական ծառի նկարագրության գլխում, արտահայտությունների տարատեսակները ներկայացնող հանգույցների տիպերն ութն են. `Boolean`, `Number`, `Text` և `Array` — լիտերալների համար, `Unary` և `Binary` — միտեղանի ու երկտեղանի գործողությունների համար և `Apply` — ենթածրագիր-ֆունկցիաների կիրառության համար։ Արտահայտության տրված ենթածառի տիպը տարբերակվում և համապատասխան հաշվարկող ֆունկցիան կանչվում է `evaluate` ֆունկցիայում.

```Go
func evaluate(n ast.Node, env *environment) *value {
	var result *value

	switch e := n.(type) {
	case *ast.Boolean:
		result = evaluateBoolean(e, env)
	case *ast.Number:
		result = evaluateNumber(e, env)
	case *ast.Text:
		result = evaluateText(e, env)
	case *ast.Array:
		result = evaluateArray(e, env)
	case *ast.Variable:
		result = evaluateVariable(e, env)
	case *ast.Unary:
		result = evaluateUnary(e, env)
	case *ast.Binary:
		result = evaluateBinary(e, env)
	case *ast.Apply:
		result = evaluateApply(e, env)
	}

	return result
}
```

## Հրամանների կատարում
